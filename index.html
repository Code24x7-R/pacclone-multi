<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Pacclone Arcade - Multiplayer</title>
    <style>
        :root {
            --player1-color: #FFFF00; /* Yellow */
            --player2-color: #00FFFF; /* Cyan */
            --player3-color: #00FF00; /* Green */
            --player4-color: #FF00FF; /* Magenta */
        }
        html, body {
            height: 100%;
            margin: 0;
            background-color: #000;
            color: #fff;
            font-family: 'Courier New', Courier, monospace;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
        }
        #lobby, #game-container, #end-screen {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            width: 100%;
            max-width: 600px;
            padding: 20px;
            box-sizing: border-box;
        }
        #lobby h1 {
            color: yellow;
            text-shadow: 2px 2px #f0f;
            font-size: 2.5em;
            margin-bottom: 20px;
        }
        #player-slots {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            width: 100%;
            margin-bottom: 20px;
        }
        .player-slot {
            border: 2px solid #555;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            font-size: 1.2em;
            transition: all 0.3s;
        }
        .player-slot.empty {
            color: #777;
        }
        .player-slot.occupied {
            border-color: var(--player-color);
            color: var(--player-color);
            text-shadow: 0 0 5px var(--player-color);
        }
        #join-controls input {
            padding: 10px;
            font-size: 1em;
            background: #111;
            border: 1px solid #fff;
            color: #fff;
            margin-right: 10px;
            border-radius: 5px;
        }
        #join-controls button, #start-game-btn, #end-screen button {
            padding: 10px 20px;
            font-size: 1em;
            font-family: 'Courier New', Courier, monospace;
            color: #000;
            background-color: #fff;
            border: 2px solid yellow;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.2s, color 0.2s;
        }
        #join-controls button:hover, #start-game-btn:hover, #end-screen button:hover {
            background-color: yellow;
            color: #000;
        }
        #start-game-btn {
            margin-top: 20px;
            width: 100%;
        }
        #status-message {
            margin-top: 15px;
            color: #aaa;
            min-height: 20px;
        }
        #game-container {
            display: none;
        }
        #hud {
            display: flex;
            justify-content: space-around;
            width: 100%;
            margin-bottom: 10px;
            flex-wrap: wrap;
        }
        .hud-player-info {
            padding: 5px;
            border-radius: 5px;
            font-size: 0.9em;
        }
        .hud-player-info.spectating {
            text-decoration: line-through;
            opacity: 0.5;
        }
        canvas {
            background-color: #000;
            border: 2px solid #fff;
            display: block;
            width: 100%;
            max-width: 600px;
            aspect-ratio: 1 / 1;
        }
        #spectator-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 3em;
            color: rgba(255, 0, 0, 0.7);
            text-shadow: 2px 2px #000;
            display: none;
            pointer-events: none;
        }
        #joystick-container {
            position: absolute;
            bottom: 30px;
            left: 30px;
            width: 150px;
            height: 150px;
            display: none; /* Hidden by default, shown for touch devices */
        }
        @media (hover: none) and (pointer: coarse) {
            #joystick-container {
                display: block;
            }
        }
    </style>
</head>
<body>
    <div id="lobby">
        <h1>PACCLONE MULTI</h1>
        <div id="player-slots">
            <div id="slot-0" class="player-slot empty">[ Player 1 ]</div>
            <div id="slot-1" class="player-slot empty">[ Player 2 ]</div>
            <div id="slot-2" class="player-slot empty">[ Player 3 ]</div>
            <div id="slot-3" class="player-slot empty">[ Player 4 ]</div>
        </div>
        <div id="join-controls">
            <input type="text" id="player-name-input" placeholder="Enter Your Name" maxlength="12">
            <button id="join-game-btn">Join Game</button>
        </div>
        <button id="start-game-btn" style="display: none;">Start Game</button>
        <div id="status-message">Connecting to server...</div>
    </div>

    <div id="game-container">
        <div id="hud"></div>
        <canvas id="gameCanvas" width="600" height="600"></canvas>
        <div id="spectator-message">SPECTATING</div>
    </div>
    
    <div id="end-screen" style="display:none;">
        <h2 id="winner-message"></h2>
        <button id="return-to-lobby-btn">Return to Lobby</button>
    </div>

    <div id="joystick-container"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/nipplejs/0.10.1/nipplejs.min.js"></script>
    <script>
        const TILE_SIZE = 30;
        const PLAYER_COLORS = ['#FFFF00', '#00FFFF', '#00FF00', '#FF00FF'];

        // --- DOM Elements ---
        const lobbyEl = document.getElementById('lobby');
        const gameContainerEl = document.getElementById('game-container');
        const endScreenEl = document.getElementById('end-screen');
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const statusMessageEl = document.getElementById('status-message');
        const playerNameInput = document.getElementById('player-name-input');
        const joinGameBtn = document.getElementById('join-game-btn');
        const startGameBtn = document.getElementById('start-game-btn');
        const returnToLobbyBtn = document.getElementById('return-to-lobby-btn');
        const playerSlots = [
            document.getElementById('slot-0'),
            document.getElementById('slot-1'),
            document.getElementById('slot-2'),
            document.getElementById('slot-3'),
        ];
        const hudEl = document.getElementById('hud');
        const spectatorMessageEl = document.getElementById('spectator-message');

        // --- Client State ---
        let ws;
        let myPlayerId = null;
        let latestGameState = null;
        let animationFrameId;

        // --- Audio ---
        let audioContext;
        const sounds = {}; // Will hold pre-generated sound functions

        function initializeAudio() {
            if (audioContext && audioContext.state !== 'closed') return;
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            } catch (e) {
                console.error("Web Audio API is not supported.");
            }
        }
        
        function playSound(type, options = {}) {
            if (!audioContext || audioContext.state === 'suspended') return;

            let oscType = 'sine', freq = 440, duration = 0.1, vol = 0.2;
            let freqSweep = false, sweepEndFreq = freq;

            switch(type) {
                case 'chomp':
                    oscType = 'square';
                    freq = 300 + Math.random() * 50;
                    duration = 0.05;
                    vol = 0.1;
                    break;
                case 'powerup':
                     oscType = 'triangle';
                    freq = 440;
                    duration = 0.4;
                    vol = 0.3;
                    freqSweep = true;
                    sweepEndFreq = 880;
                    break;
                case 'eatGhost':
                    oscType = 'sawtooth';
                    freq = 500;
                    duration = 0.2;
                    vol = 0.4;
                    freqSweep = true;
                    sweepEndFreq = 1200;
                    break;
                case 'death':
                    oscType = 'sawtooth';
                    freq = 400;
                    duration = 0.6;
                    vol = 0.5;
                    freqSweep = true;
                    sweepEndFreq = 50;
                    break;
                 case 'win':
                    // Play a little victory jingle
                    const notes = [523.25, 659.25, 783.99, 1046.50];
                    notes.forEach((noteFreq, i) => {
                        setTimeout(() => playSound('note', { freq: noteFreq, duration: 0.1 }), i * 110);
                    });
                    return;
                case 'note':
                    oscType = 'triangle';
                    freq = options.freq || 440;
                    duration = options.duration || 0.1;
                    vol = 0.3;
                    break;
            }
            
            const now = audioContext.currentTime;
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);

            oscillator.type = oscType;
            gainNode.gain.setValueAtTime(0, now);
            gainNode.gain.linearRampToValueAtTime(vol, now + 0.01);
            
            oscillator.frequency.setValueAtTime(freq, now);
            if(freqSweep) {
                 oscillator.frequency.exponentialRampToValueAtTime(sweepEndFreq, now + duration);
            }
            
            gainNode.gain.exponentialRampToValueAtTime(0.001, now + duration);

            oscillator.start(now);
            oscillator.stop(now + duration);
        }

        // --- WebSocket Logic ---
        function connect() {
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const host = window.location.host;
            ws = new WebSocket(`${protocol}//${host}`);

            ws.onopen = () => {
                statusMessageEl.textContent = "Connected. Join a game!";
                console.log("Connected to server");
            };

            ws.onmessage = (event) => {
                const message = JSON.parse(event.data);
                switch (message.type) {
                    case 'assignId':
                        myPlayerId = message.playerId;
                        statusMessageEl.textContent = `Joined! You are Player ${message.playerIndex + 1}.`;
                        joinGameBtn.disabled = true;
                        playerNameInput.disabled = true;
                        break;
                    case 'lobbyUpdate':
                        updateLobbyUI(message.lobby);
                        break;
                    case 'gameStart':
                        latestGameState = message.gameState;
                        startGame();
                        break;
                    case 'gameState':
                        latestGameState = message.gameState;
                        handleSoundEvents(message.events);
                        break;
                    case 'error':
                        statusMessageEl.textContent = `Error: ${message.message}`;
                        break;
                    case 'gameOver':
                        showEndScreen(message.winner);
                        break;
                }
            };

            ws.onclose = () => {
                statusMessageEl.textContent = "Disconnected from server. Please refresh.";
                if (animationFrameId) cancelAnimationFrame(animationFrameId);
                showLobby();
            };

            ws.onerror = (err) => {
                console.error("WebSocket error:", err);
                statusMessageEl.textContent = "Connection error.";
            };
        }

        function sendMessage(type, payload) {
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({ type, ...payload }));
            }
        }
        
        function handleSoundEvents(events = []) {
            if (!events) return;
            events.forEach(event => {
                // Check if the event is for me, or if it's a global sound
                if (event.playerId === myPlayerId || !event.playerId) {
                    playSound(event.sound);
                }
            });
        }

        // --- UI Logic ---
        function showLobby() {
            lobbyEl.style.display = 'flex';
            gameContainerEl.style.display = 'none';
            endScreenEl.style.display = 'none';
            joinGameBtn.disabled = false;
            playerNameInput.disabled = false;
        }

        function startGame() {
            lobbyEl.style.display = 'none';
            gameContainerEl.style.display = 'flex';
            endScreenEl.style.display = 'none';
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            animationFrameId = requestAnimationFrame(gameLoop);
        }
        
        function showEndScreen(winner) {
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            gameContainerEl.style.display = 'none';
            endScreenEl.style.display = 'flex';
            if (winner) {
                document.getElementById('winner-message').textContent = `${winner.name} is the winner!`;
                playSound('win');
            } else {
                 document.getElementById('winner-message').textContent = `Game Over!`;
            }
        }

        function updateLobbyUI(lobby) {
            lobby.players.forEach((player, i) => {
                const slot = playerSlots[i];
                if (player) {
                    slot.textContent = player.name + (player.id === myPlayerId ? " (You)" : "");
                    slot.className = 'player-slot occupied';
                    slot.style.setProperty('--player-color', PLAYER_COLORS[i]);
                } else {
                    slot.textContent = `[ Player ${i + 1} ]`;
                    slot.className = 'player-slot empty';
                }
            });

            // Show start button for the host (first player) when there are players
            const amIHost = lobby.players[0] && lobby.players[0].id === myPlayerId;
            startGameBtn.style.display = amIHost && lobby.players.some(p => p) ? 'block' : 'none';
        }

        function updateHUD(players) {
            hudEl.innerHTML = '';
            players.forEach(player => {
                if(!player) return;
                const playerInfo = document.createElement('div');
                playerInfo.className = 'hud-player-info';
                playerInfo.style.color = PLAYER_COLORS[player.index];
                if (player.state === 'spectating') {
                    playerInfo.classList.add('spectating');
                }
                playerInfo.textContent = `${player.name}: ${player.score} | Lives: ${player.lives}`;
                hudEl.appendChild(playerInfo);
            });
        }

        // --- Game Loop & Drawing ---
        function gameLoop() {
            if (latestGameState) {
                draw();
            }
            animationFrameId = requestAnimationFrame(gameLoop);
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            const state = latestGameState;
            if (!state) return;

            const me = state.players.find(p => p && p.id === myPlayerId);
            if(me && me.state === 'spectating') {
                spectatorMessageEl.style.display = 'block';
            } else {
                spectatorMessageEl.style.display = 'none';
            }

            drawMap(state.map);
            drawPellets(state.map);
            state.ghosts.forEach(ghost => drawGhost(ghost, state.ghostFrightenedTimer));
            state.players.forEach(player => {
                if (player && player.state === 'active') {
                    drawPlayer(player);
                }
            });
            updateHUD(state.players);
        }

        function drawMap(map) {
            for (let r = 0; r < map.length; r++) {
                for (let c = 0; c < map[r].length; c++) {
                    if (map[r][c] === 1) { // Wall
                        ctx.fillStyle = 'blue';
                        ctx.fillRect(c * TILE_SIZE, r * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                    }
                }
            }
        }

        function drawPellets(map) {
            for (let r = 0; r < map.length; r++) {
                for (let c = 0; c < map[r].length; c++) {
                    if (map[r][c] === 2) { // Pellet
                        ctx.fillStyle = 'grey';
                        ctx.beginPath();
                        ctx.arc(c * TILE_SIZE + TILE_SIZE / 2, r * TILE_SIZE + TILE_SIZE / 2, TILE_SIZE / 8, 0, Math.PI * 2);
                        ctx.fill();
                    } else if (map[r][c] === 3) { // Power-up
                        ctx.fillStyle = 'darkred';
                        ctx.beginPath();
                        ctx.arc(c * TILE_SIZE + TILE_SIZE / 2, r * TILE_SIZE + TILE_SIZE / 2, TILE_SIZE / 4, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            }
        }

        function drawPlayer(player) {
            ctx.fillStyle = PLAYER_COLORS[player.index];
            ctx.beginPath();

            let directionAngle = 0;
            if (player.dx > 0) directionAngle = 0;
            else if (player.dx < 0) directionAngle = Math.PI;
            else if (player.dy > 0) directionAngle = Math.PI / 2;
            else if (player.dy < 0) directionAngle = -Math.PI / 2;

            const startAngle = directionAngle + player.mouthAngle;
            const endAngle = directionAngle + Math.PI * 2 - player.mouthAngle;

            ctx.arc(player.x, player.y, player.radius, startAngle, endAngle);
            ctx.lineTo(player.x, player.y);
            ctx.fill();

            // Draw player name above them
            ctx.fillStyle = "white";
            ctx.font = "10px Courier New";
            ctx.textAlign = "center";
            ctx.fillText(player.name, player.x, player.y - player.radius - 5);
        }

        function drawGhost(ghost, frightenedTimer) {
            const ghostRadius = TILE_SIZE / 3;
            if (ghost.eaten) {
                // Draw only eyes if eaten
                ctx.fillStyle = 'white';
                ctx.beginPath();
                ctx.arc(ghost.x - ghostRadius / 2, ghost.y - ghostRadius / 2, ghostRadius / 2.5, 0, Math.PI * 2);
                ctx.arc(ghost.x + ghostRadius / 2, ghost.y - ghostRadius / 2, ghostRadius / 2.5, 0, Math.PI * 2);
                ctx.fill();
                return;
            }
            
            ctx.fillStyle = ghost.frightened ? 'blue' : ghost.color;
            if (ghost.frightened && frightenedTimer < 3000 && Math.floor(frightenedTimer / 250) % 2 === 0) {
                 ctx.fillStyle = 'white';
            }
            
            ctx.beginPath();
            ctx.arc(ghost.x, ghost.y, ghostRadius, Math.PI, 0, false);
            ctx.rect(ghost.x - ghostRadius, ghost.y, ghostRadius * 2, ghostRadius);
            ctx.fill();
            
            // Eyes
            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.arc(ghost.x - ghostRadius / 2, ghost.y - ghostRadius / 4, ghostRadius / 2, 0, Math.PI * 2);
            ctx.arc(ghost.x + ghostRadius / 2, ghost.y - ghostRadius / 4, ghostRadius / 2, 0, Math.PI * 2);
            ctx.fill();

            // Pupils
            ctx.fillStyle = 'black';
            ctx.beginPath();
            let pupilXOffset = ghost.dx * (ghostRadius / 4);
            let pupilYOffset = ghost.dy * (ghostRadius / 4);
            ctx.arc(ghost.x - ghostRadius / 2 + pupilXOffset, ghost.y - ghostRadius/4 + pupilYOffset, ghostRadius / 4, 0, Math.PI*2);
            ctx.arc(ghost.x + ghostRadius / 2 + pupilXOffset, ghost.y - ghostRadius/4 + pupilYOffset, ghostRadius / 4, 0, Math.PI*2);
            ctx.fill();
        }

        // --- Input Handling ---
        function setupInputListeners() {
            document.addEventListener('keydown', (e) => {
                let direction = null;
                switch (e.key) {
                    case 'ArrowUp': case 'w': direction = { dx: 0, dy: -1 }; break;
                    case 'ArrowDown': case 's': direction = { dx: 0, dy: 1 }; break;
                    case 'ArrowLeft': case 'a': direction = { dx: -1, dy: 0 }; break;
                    case 'ArrowRight': case 'd': direction = { dx: 1, dy: 0 }; break;
                }
                if (direction) {
                    e.preventDefault();
                    sendMessage('input', { direction });
                }
            });
            
             // Touch controls
            if ('ontouchstart' in window) {
                const joystickManager = nipplejs.create({
                    zone: document.getElementById('joystick-container'),
                    mode: 'static',
                    position: { left: '50%', top: '50%' },
                    color: 'white',
                    size: 120
                });

                let lastDirection = null;
                joystickManager.on('move', (evt, data) => {
                    if (data.direction) {
                        let newDirection = data.direction.angle;
                        if (newDirection !== lastDirection) {
                            lastDirection = newDirection;
                             sendMessage('input', { direction: getDirectionFromAngle(data.angle.degree) });
                        }
                    }
                });
                 joystickManager.on('end', () => {
                    lastDirection = null;
                });
            }
        }
        
        function getDirectionFromAngle(angle) {
            if (angle >= 45 && angle < 135) return { dx: 0, dy: -1 }; // Up
            if (angle >= 135 && angle < 225) return { dx: -1, dy: 0 }; // Left
            if (angle >= 225 && angle < 315) return { dx: 0, dy: 1 }; // Down
            return { dx: 1, dy: 0 }; // Right
        }

        // --- Window Load ---
        window.onload = () => {
            connect();
            setupInputListeners();

            joinGameBtn.onclick = () => {
                initializeAudio(); // User gesture
                const name = playerNameInput.value.trim();
                if (name) {
                    sendMessage('join', { name });
                } else {
                    statusMessageEl.textContent = "Please enter a name.";
                }
            };
            
            startGameBtn.onclick = () => {
                sendMessage('startGame', {});
            };
            
            returnToLobbyBtn.onclick = () => {
                // This doesn't send a message; the client just returns to the lobby UI.
                // The server will handle resetting the lobby state when all players disconnect or a new game starts.
                latestGameState = null;
                showLobby();
            };
        };
    </script>
</body>
</html>
